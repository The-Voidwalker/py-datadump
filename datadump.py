"""Please see https://github.com/The-Voidwalker/py-datadump/blob/main/README.md
for details on configuring this script."""

USER = "YOUR USERNAME HERE"  # Name of user account that will be logged in as
HOSTNAME = "https://meta.miraheze.org"  # Replace with the URL of your wiki
DUMPS_DIRECTORY = r"."  # Directory data dumps will be downloaded to
DUMP_TYPES = ["xml"]  # Include dump types here
# For example, to do both image and xml dumps, use
# DUMP_TYPES = ['xml', 'image']

# It is recommended that you use an OAUTH consumer for logging in, see the URL at the top
# of this file for additional instructions.
# You only need to define one authentication option, however if the script cannot login,
# it will attempt each other login method in this order: OAUTH2 -> OAUTH1 -> Password
# OAuth 2
OAUTH2_TOKEN = "TOKEN HERE"
# OAuth 1
OAUTH1_CONSUMER_KEY = "CONSUMER KEY"
OAUTH1_CONSUMER_SECRET = "CONSUMER SECRET"
OAUTH1_ACCESS_TOKEN = "ACCESS TOKEN"
OAUTH1_ACCESS_SECRET = "ACCESS SECRET"
# Password
PASSWORD = "PASSWORD HERE"  # If you set this value, please mind who can read this file

# DataDump handling
DELETE_EXISTING = True  # Delete existing dumps that prevent us from generating new ones
DELETE_AFTER_DOWNLOAD = False  # Delete the dumps we generate once they are downloaded
WAIT_FOR_DUMPS = 30  # Seconds to wait for dumps to generate

# Retry on connection failure settings
MAX_RETRIES = 5  # Maximum attempts to retry on a connection error
RETRY_TIMEOUT = 30  # Seconds inbetween retry attempts

# If your username is actually YOUR USERNAME HERE for some reason, set this to true
ACCEPT_DEFAULT_USERNAME = False

# The following values do not need to be changed on Miraheze wikis
SCRIPT_PATH = "/w"
API_PATH = "/api.php"  # location of api.php after script path

DEFAULT_USER_AGENT = "py-datadump script"  # Custom user agent for requests

"""Do not edit this file below this line unless you know what you are doing!"""

import sys
import time
import requests
from pathlib import Path
from urllib.parse import urlparse, parse_qs

requests.utils.default_user_agent = lambda: DEFAULT_USER_AGENT

SESSION = requests.Session()
DUMPS_DIRECTORY = Path(DUMPS_DIRECTORY)
if not DUMPS_DIRECTORY.is_dir():
    print("ERROR: DUMPS_DIRECTORY must be pointing at a directory!")
    sys.exit(1)

if USER == "YOUR USERNAME HERE":
    print("WARNING: Username appears to be unconfigured!")
    if not ACCEPT_DEFAULT_USERNAME:
        sys.exit(1)
if OAUTH2_TOKEN == "TOKEN HERE":
    OAUTH2_TOKEN = None
if OAUTH1_CONSUMER_KEY == "CONSUMER KEY":
    OAUTH1_CONSUMER_KEY = None
if OAUTH1_CONSUMER_SECRET == "CONSUMER SECRET":
    OAUTH1_CONSUMER_SECRET = None
if OAUTH1_ACCESS_TOKEN == "ACCESS TOKEN":
    OAUTH1_ACCESS_TOKEN = None
if OAUTH1_ACCESS_SECRET == "ACCESS SECRET":
    OAUTH1_ACCESS_SECRET = None
if (
    OAUTH1_CONSUMER_KEY
    and OAUTH1_CONSUMER_SECRET
    and OAUTH1_ACCESS_TOKEN
    and OAUTH1_ACCESS_SECRET
):
    try:
        from requests_oauthlib import OAuth1

        OAUTH1_TOKEN = OAuth1(
            OAUTH1_CONSUMER_KEY,
            OAUTH1_CONSUMER_SECRET,
            OAUTH1_ACCESS_TOKEN,
            OAUTH1_ACCESS_SECRET,
        )
    except ImportError:
        print("ERROR: Please install requests_oauthlib to use OAUTH1 authentication")
        print("OAUTH1 authentication disabled!")
        OAUTH1_TOKEN = None
if PASSWORD == "PASSWORD HERE":
    PASSWORD = None

if not (OAUTH2_TOKEN or OAUTH1_TOKEN or PASSWORD):
    print("ERROR: No authentication method has been configured!")
    sys.exit(1)


class OAuth2Auth(requests.auth.AuthBase):
    """Simple class to add an OAuth2 authorization header to a request."""

    def __init__(self, token):
        self.token = token

    def __call__(self, r):
        """Add Authorization header."""
        r.headers["Authorization"] = f"Bearer {self.token}"
        return r


class Api:
    """Describes the MediaWiki API.

    Based on the class of the same name from Void-bot.
    """

    query = {"action": "query", "format": "json", "assertuser": USER}

    def __init__(self):
        """Init Api class.

        Only supports wikis using https.
        Configuration for this class is handled solely by the constants defined above
        """
        self.hostname = urlparse(HOSTNAME).hostname  # Parse for safety
        self.script_path = SCRIPT_PATH
        self.api_path = API_PATH
        self.url = f"https://{self.hostname}{self.script_path}{self.api_path}"
        self.try_logins()
        self._dumps = None

    def do_get(self, query):
        """Perform a get request with provided query.

        Handles timeouts and retries.
        Returns response JSON from handle_resp if valid, None if not.
        Does not handle API errors.
        """
        attempts = 0
        while attempts < MAX_RETRIES:
            if attempts > 0:
                time.sleep(RETRY_TIMEOUT)
            try:
                attempts += 1
                return self.handle_resp(
                    SESSION.get(
                        self.url, params=query, auth=self.oauth if self.oauth else None
                    )
                )
            except ConnectionError as err:
                print(f"Attempt {attempts} out of {MAX_RETRIES} failed.")
                print(err)

    def do_post(self, query):
        """Perform a post with provided query.

        Handles timeouts and retries.
        Returns response JSON from handle_resp if successful, None if not.
        Does not handle API errors.
        """
        attempts = 0
        while attempts < MAX_RETRIES:
            if attempts > 0:
                time.sleep(RETRY_TIMEOUT)
            try:
                attempts += 1
                return self.handle_resp(
                    SESSION.post(
                        self.url, data=query, auth=self.oauth if self.oauth else None
                    )
                )
            except ConnectionError as err:
                print(f"Attempt {attempts} out of {MAX_RETRIES} failed.")
                print(err)

    def handle_resp(self, response):
        """Process server response for validity.

        Raises errors if issues are found in response.
        :return: server response as JSON
        """
        if response.status_code != 200:
            raise ConnectionError(
                f'Received HTTP "{response.status_code}"'
                + f' from "{self.hostname}"; expected HTTP 200'
            )
        r_json = response.json()
        if "error" in r_json:
            raise ApiError(f'{r_json["error"]["code"]}: {r_json["error"]["info"]}')
        return r_json

    def get_token(self, token_type="csrf"):
        """Fetch a token.

        :param type: (string) Type of token to fetch
        :return: (string) token
        """
        query = self.query.copy()
        query.update({"meta": "tokens", "type": token_type})
        if token_type == "login":
            query.pop("assertuser")  # Can't be this user if we aren't logged in
        resp = self.do_get(query)
        return resp["query"]["tokens"][f"{token_type}token"]

    def try_logins(self):
        """Validate login options."""
        test_query = self.query.copy()
        test_query.update({"meta": "siteinfo"})

        if OAUTH2_TOKEN:
            self.oauth = OAuth2Auth(OAUTH2_TOKEN)
            try:
                self.do_get(test_query)
                return  # Token is good, don't check others
            except ApiError:
                self.oauth = None  # Auth failed or other problem
                print("WARNING: OAuth2 authentication failed")

        if OAUTH1_TOKEN:
            self.oauth = OAUTH1_TOKEN
            try:
                self.do_get(test_query)
                return  # Token is good, don't check others
            except ApiError:
                self.oauth = None  # Auth failed or other problem
                print("WARNING: OAuth1 authentication failed")

        if PASSWORD:
            login_token = self.get_token(token_type="login")
            login_query = self.query.copy()
            login_query.pop("assertuser")  # Not logged in yet
            login_query.update(
                {"lgname": USER, "lgpassword": PASSWORD, "lgtoken": login_token}
            )
            self.do_get(login_query)
            try:
                self.do_get(test_query)
                return  # Password is good, cookies are stored to session
            except ApiError:
                print("WARNING: Password authentication failed")

        print("ERROR: No authentication methods left to try!")
        sys.exit(1)

    def get_dumps(self, refresh=False):
        """Get a list of dumps on this wiki.

        :param refresh: Refresh the cached list, should it exist
        """
        if self._dumps and not refresh:
            return self._dumps
        query = self.query.copy()
        query.update({"action": "viewdumps"})
        resp = self.do_get(query)
        self._dumps = resp["viewdumps"]
        return self._dumps

    def get_dump_url(self, dump_type):
        """Get the information of a dump of the specified type."""
        dumps = self.get_dumps()
        for dump in dumps:
            if dump["type"] == dump_type:
                return dump["link"]
        return None

    def dump_create(self, dump_type="xml"):
        """Creates a data dump.

        :param dump_type: (string) the type of the datadump.
        """
        query = self.query.copy()
        query.update(
            {"action": "generatedumps", "type": dump_type, "token": self.get_token()}
        )
        self.do_post(query)

    def dump_delete(self, dump_type, filename):
        """Deletes a data dump.

        :param filename: Name of dump file to be deleted.
        :param dump_type: Type of dump to be deleted.
        """
        query = self.query.copy()
        query.update(
            {
                "action": "deletedumps",
                "type": dump_type,
                "filename": filename,
                "token": self.get_token(),
            }
        )
        self.do_post(query)

    def dump_download(self, dump_type="", url=""):
        """Downloads a data dump.

        Provide either the url or the type, not both.
        :param dump_type: Type of dump to download.
        :param url: URL of dump to download.
        """
        if dump_type and not url:
            url = self.get_dump_url(dump_type)
        filename = DUMPS_DIRECTORY / parse_qs(urlparse(url).query)["dump"][0]
        if filename.exists():
            raise FileExistsError(
                f'Cannot download dump to file! File "{filename}" already exists!'
            )
        resp = SESSION.get(url, allow_redirects=True)
        with open(filename, "wb") as file:
            file.write(resp.content)


class ApiError(Exception):
    """The API returned some error."""


def main():
    """Run everything."""
    api = Api()
    dumps = api.get_dumps()
    for dump in dumps:
        if dump["type"] in DUMP_TYPES:
            print(f'NOTICE: A dump of type "{dump["type"]}" already exists.')
            if DELETE_EXISTING:
                print(f'NOTICE: Deleting existing dump "{dump["filename"]}"...')
                api.dump_delete(dump["type"], dump["filename"])
            else:
                DUMP_TYPES.pop(DUMP_TYPES.index(dump["type"]))
                print(f'Skipping dump type "{dump["type"]}".')

    for dump_type in DUMP_TYPES:
        api.dump_create(dump_type)

    time.sleep(WAIT_FOR_DUMPS)

    dumps = api.get_dumps(refresh=True)
    for dump in dumps:
        if dump["type"] in DUMP_TYPES:
            print(f'Downloading dump "{dump["filename"]}".')
            api.dump_download(url=dump["link"])
            if DELETE_AFTER_DOWNLOAD:
                print(f'Deleting dump "{dump["filename"]}".')
                api.dump_delete(dump["type"], dump["filename"])


main()
