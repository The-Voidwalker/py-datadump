"""Please see https://github.com/The-Voidwalker/py-datadump/blob/main/README.md
for details on configuring this script."""

CONFIG = {
    "default": {
        "user": "YOUR USERNAME HERE",
        "url": "https://meta.miraheze.org",
        "dump_types": ["xml"],
        "downloads_folder": "/path/to/downloads",
        "authentication": {
            "oauth2": "TOKEN HERE",
            "oauth1": {
                "consumer_key": "KEY",
                "consumer_secret": "SECRET",
                "access_token": "TOKEN",
                "access_key": "KEY",
            },
            "password": "PASSWORD",
        },
        "delete_existing": True,
        "download_existing": False,
        "delete_after_download": False,
        "wait_for_dumps": 30,
        "max_retries": 5,
        "retry_timeout": 30,
        "accept_default_username": False,
        "script_path": "/w",
        "api_path": "/api.php",
        "user_agent": "py-datadump script",
    },
}

"""Do not edit this file below this line unless you know what you are doing!"""

import sys
import time
import requests
from pathlib import Path
from urllib.parse import urlparse, parse_qs


class OAuth2Auth(requests.auth.AuthBase):
    """Simple class to add an OAuth2 authorization header to a request."""

    def __init__(self, token):
        self.token = token

    def __call__(self, r):
        """Add Authorization header."""
        r.headers["Authorization"] = f"Bearer {self.token}"
        return r


class Api:
    """Describes the MediaWiki API.

    Based on the class of the same name from Void-bot.
    """

    query = {"action": "query", "format": "json"}

    def __init__(
        self,
        user,
        url,
        authentication,
        max_retries=5,
        retry_timeout=30,
        script_path="/w",
        api_path="/api.php",
        session=requests.session(),
        user_agent="py-datadump script",
    ):
        """Init Api class.

        Only supports wikis using https.
        Configuration for this class is handled solely by the constants defined above
        """
        self.hostname = urlparse(url).hostname  # Parse for safety
        self.script_path = script_path
        self.api_path = api_path
        self.url = f"https://{self.hostname}{self.script_path}{self.api_path}"
        self._auth = authentication
        self.user = user
        self.max_retries = max_retries
        self.retry_timeout = retry_timeout
        self.session = session
        self.session.headers.update({"User-Agent": user_agent})
        self.query["assertuser"] = self.user
        self.try_logins()
        self._dumps = None

    def do_get(self, query):
        """Perform a get request with provided query.

        Handles timeouts and retries.
        Returns response JSON from handle_resp if valid, None if not.
        Does not handle API errors.
        """
        return self.do_request("get", query)

    def do_post(self, query):
        """Perform a post with provided query.

        Handles timeouts and retries.
        Returns response JSON from handle_resp if successful, None if not.
        Does not handle API errors.
        """
        return self.do_request("post", query)

    def do_request(self, method, query):
        """Perform a request of the specified method.

        Handles timeouts and retries.
        Returns response JSON from handle_resp if successful, None if not.
        Does not handle API errors.
        """
        attempts = 0
        while attempts < self.max_retries:
            if attempts > 0:
                time.sleep(self.retry_timeout)
            try:
                attempts += 1
                return self.handle_resp(
                    self.session.request(
                        method,
                        self.url,
                        params=query,
                        auth=self.oauth if self.oauth else None,
                    )
                )
            except ConnectionError as err:
                print(f"Attempt {attempts} out of {self.max_retries} failed.")
                print(err)
        raise ConnectionError("Maximum retries reached!")

    def handle_resp(self, response):
        """Process server response for validity.

        Raises errors if issues are found in response.
        :return: server response as JSON
        """
        if response.status_code != 200:
            raise ConnectionError(
                f'Received HTTP "{response.status_code}"'
                + f' from "{self.hostname}"; expected HTTP 200'
            )
        r_json = response.json()
        if "error" in r_json:
            raise ApiError(f'{r_json["error"]["code"]}: {r_json["error"]["info"]}')
        return r_json

    def get_token(self, token_type="csrf"):
        """Fetch a token.

        :param type: (string) Type of token to fetch
        :return: (string) token
        """
        query = self.query.copy()
        query.update({"meta": "tokens", "type": token_type})
        if token_type == "login":
            query.pop("assertuser")  # Can't be this user if we aren't logged in
        resp = self.do_get(query)
        return resp["query"]["tokens"][f"{token_type}token"]

    def try_logins(self):
        """Validate login options."""
        test_query = self.query.copy()
        test_query.update({"meta": "siteinfo"})

        if "oauth2" in self._auth:
            self.oauth = OAuth2Auth(self._auth["oauth2"])
            try:
                self.do_get(test_query)
                return  # Token is good, don't check others
            except ApiError:
                self.oauth = None  # Auth failed or other problem
                print("WARNING: OAuth2 authentication failed")

        if "oauth1" in self._auth:
            self.oauth = self._auth["oauth1"]["auth"]
            try:
                self.do_get(test_query)
                return  # Token is good, don't check others
            except ApiError:
                self.oauth = None  # Auth failed or other problem
                print("WARNING: OAuth1 authentication failed")

        if "password" in self._auth:
            login_token = self.get_token(token_type="login")
            login_query = self.query.copy()
            login_query.pop("assertuser")  # Not logged in yet
            login_query.update(
                {
                    "lgname": self.user,
                    "lgpassword": self._auth["password"],
                    "lgtoken": login_token,
                }
            )
            self.do_get(login_query)
            try:
                self.do_get(test_query)
                return  # Password is good, cookies are stored to session
            except ApiError:
                print("WARNING: Password authentication failed")

        print("ERROR: No authentication methods left to try!")
        sys.exit(1)

    def get_dumps(self, refresh=False):
        """Get a list of dumps on this wiki.

        :param refresh: Refresh the cached list, should it exist
        """
        if self._dumps and not refresh:
            return self._dumps
        query = self.query.copy()
        query.update({"action": "viewdumps"})
        resp = self.do_get(query)
        self._dumps = resp["viewdumps"]
        return self._dumps

    def get_dump_url(self, dump_type):
        """Get the information of a dump of the specified type."""
        dumps = self.get_dumps()
        for dump in dumps:
            if dump["type"] == dump_type:
                if dump["link"] == dump["filename"]:
                    raise Warning(
                        f'It appears the dump "{dump["filename"]}" has yet to be generated.'
                    )
                return dump["link"]
        return None

    def dump_create(self, dump_type="xml"):
        """Creates a data dump.

        :param dump_type: (string) the type of the datadump.
        """
        query = self.query.copy()
        query.update(
            {"action": "generatedumps", "type": dump_type, "token": self.get_token()}
        )
        self.do_post(query)

    def dump_delete(self, dump_type, filename):
        """Deletes a data dump.

        :param filename: Name of dump file to be deleted.
        :param dump_type: Type of dump to be deleted.
        """
        query = self.query.copy()
        query.update(
            {
                "action": "deletedumps",
                "type": dump_type,
                "filename": filename,
                "token": self.get_token(),
            }
        )
        self.do_post(query)

    def dump_download(self, directory, dump_type="", url=""):
        """Downloads a data dump.

        Provide either the url or the type, not both.
        :param dump_type: Type of dump to download.
        :param url: URL of dump to download.
        """
        if dump_type and not url:
            url = self.get_dump_url(dump_type)
        p_url = urlparse(url)
        if "Special:DataDump&action=download" in url:
            filename = parse_qs(p_url.query)["dump"][0]
        else:
            filename = p_url.path.split("/")[-1]
        file = directory / filename
        if file.exists():
            raise FileExistsError(
                f'Cannot download dump to file! File "{file}" already exists!'
            )
        resp = self.session.get(url, allow_redirects=True)
        with open(file, "wb") as f:
            f.write(resp.content)


class ApiError(Exception):
    """The API returned some error."""


def process_config():
    """Process config to ensure validity and enforce defaults."""
    if "default" not in CONFIG:
        print("NOTICE: No default configuration detected")
        default = {}
    else:
        default = CONFIG["default"]

    for name in [key for key in CONFIG if key != "default"]:
        # Populate defaults
        for key, value in default.items():
            if key not in CONFIG[name]:
                CONFIG[name][key] = value

        if "url" not in CONFIG[name]:
            print(f"ERROR: No url is configured for {name}")
            sys.exit(1)

        if "dump_types" not in CONFIG[name]:
            print(f"ERROR: Dump types have not been configured for {name}")
            sys.exit(1)

        # Validate downloads folder
        if "downloads_folder" not in CONFIG[name]:
            print(f"ERROR: downloads_folder is not configured for {name}")
            sys.exit(1)
        CONFIG[name]["downloads_folder"] = Path(CONFIG[name]["downloads_folder"])
        if not CONFIG[name]["downloads_folder"].is_dir():
            print("ERROR: downloads_directory must be pointing at a directory!")
            print(f'Currently pointing at "{CONFIG[name]["downloads_folder"]}"')
            sys.exit(1)

        # Validate user name
        if "user" not in CONFIG[name] or (
            CONFIG[name]["user"] == "YOU USERNAME HERE"
            and "accept_default_username" in CONFIG[name]
            and CONFIG[name]["accept_default_username"]
        ):
            print(f"ERROR: user is not configured for {name}")
            sys.exit(1)

        # Validate authentication
        if "authentication" not in CONFIG[name]:
            print(f"ERROR: No authentication configured for {name}")
            sys.exit(1)
        if (
            "oauth2" in CONFIG[name]["authentication"]
            and CONFIG[name]["authentication"]["oauth2"] == "TOKEN HERE"
        ):
            CONFIG[name]["authentication"].pop("oauth2")
        if (
            "password" in CONFIG[name]["authentication"]
            and CONFIG[name]["authentication"]["password"] == "PASSWORD"
        ):
            CONFIG[name]["authentication"].pop("password")

        # Process oauth1 authentication config
        if "oauth1" in CONFIG[name]["authentication"]:
            if (
                "consumer_key" not in CONFIG[name]["authentication"]["oauth1"]
                or CONFIG[name]["authentication"]["oauth1"]["consumer_key"] == "KEY"
                or "consumer_token" not in CONFIG[name]["authentication"]["oauth1"]
                or CONFIG[name]["authentication"]["oauth1"]["consumer_token"] == "TOKEN"
                or "access_token" not in CONFIG[name]["authentication"]["oauth1"]
                or CONFIG[name]["authentication"]["oauth1"]["access_token"] == "TOKEN"
                or "access_secret" not in CONFIG[name]["authentication"]["oauth1"]
                or CONFIG[name]["authentication"]["oauth1"]["access_key"] == "KEY"
            ):
                CONFIG[name]["authentication"].pop("oauth1")
            else:
                try:
                    from requests_oauthlib import OAuth1

                    CONFIG[name]["authentication"]["oauth1"]["auth"] = OAuth1(
                        CONFIG[name]["authentication"]["oauth1"]["consumer_key"],
                        CONFIG[name]["authentication"]["oauth1"]["consumer_token"],
                        CONFIG[name]["authentication"]["oauth1"]["access_token"],
                        CONFIG[name]["authentication"]["oauth1"]["access_key"],
                    )
                except ImportError:
                    print(
                        "ERROR: Please install requests_oauthlib to use OAUTH1 authentication"
                    )
                    print("OAUTH1 authentication disabled!")
                    CONFIG[name]["authentication"].pop("oauth1")

        # authentication block has no good config
        if (
            "oauth2" not in CONFIG[name]["authentication"]
            or "oauth1" not in CONFIG[name]["authentication"]
            or "password" not in CONFIG[name]["authentication"]
        ):
            print(f"ERROR: No valid authentication for {name} has been configured!")
            sys.exit(1)


def run_one(name, conf):
    """Processes one single wiki."""
    api = Api(**conf)
    dumps = api.get_dumps()
    types = conf["dump_types"]
    download_dir = conf["downloads_folder"]

    # Process existing dumps
    for dump in dumps:
        if dump["type"] in types:
            print(f'NOTICE: A dump of type "{dump["type"]}" already exists for {name}.')
            if conf["download_existing"]:
                try:
                    api.dump_download(download_dir, dump_type=dump["type"])
                    print(f"Downloaded existing dump for {name}")
                except Warning as warn:
                    print(f"WARNING: Could not download existing dump for {name}:")
                    print(warn)
            if conf["delete_existing"]:
                print(f'NOTICE: Deleting existing dump "{dump["filename"]}" for {name}')
                api.dump_delete(dump["type"], dump["filename"])
            else:
                types.pop(types.index(dump["type"]))
                print(f'Skipping dump type "{dump["type"]}" for {name}')

    # Queue generation of new dumps
    for dump_type in types:
        api.dump_create(dump_type)

    wanted = types.clone()
    while len(wanted) > 0:
        time.sleep(conf["wait_for_dumps"])

        # Refresh dumps list
        dumps = api.get_dumps()
        for dump in dumps:
            if dump["type"] in wanted:
                if dump["link"] == dump["filename"]:
                    print(
                        f'NOTICE: {dump["type"]} has not finised generating for {name}, checking next...'
                    )
                    continue
                api.dump_download(download_dir, url=dump["link"])
                wanted.pop(wanted.index(dump["type"]))
                print(f'NOTICE: Downloaded dump "{dump["filename"]}" for {name}')
                if conf["delete_after_download"]:
                    api.dump_delete(dump["type"], dump["filename"])
                    print(f'NOTICE: Dump type {dump["type"]} deleted for {name}')


def main():
    """Run everything."""
    process_config()
    if "default" in CONFIG and "url" in CONFIG["default"]:
        run_one("default", CONFIG["default"])
    for name, conf in [key for key in CONFIG if key != "default"]:
        run_one(name, conf)


main()


def test():
    """Testing poor code :)"""
    foo = {
        "bar": "baz",
        "bur": "bell",
        "hee": "hoo",
        "funky": {"stuff": "thing"},
        "a": "b",
        "c": "D",
        "e": "f",
        "ya": "boi",
        "test": "in progress",
    }
